import os
import json
from collections import Counter, defaultdict
import openai
import re

from glob import glob
from tqdm import tqdm

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")  # Set your key here or in env
openai.api_key = OPENAI_API_KEY

def find_json_files(root_dir):
    for subdir, _, files in os.walk(root_dir):
        for file in files:
            if file.lower().endswith('.json'):
                yield os.path.join(subdir, file)

def get_vulnerability_type(obj):
    title = obj.get("title", "")
    description = obj.get("description", "")
    recommendation = obj.get("recommendation", "")

    entry = f"Title: {title}\nDescription: {description}\nRecommendation: {recommendation}"

    prompt = (
        """
        Using this list of web3 vulnerabilities, read the following text and determine which category applies.
        Choose EXACTLY ONE category from this list:

        1. Access Control & Authorization
           - Function Default Visibility (SWC-100): Missing explicit function visibility allows unintended external calls
           - State Variable Default Visibility (SWC-108): State variables without explicit visibility may expose sensitive data
           - Authorization through tx.origin (SWC-115): Using tx.origin for auth is phishing-prone
           - Calls Only to Trusted Addresses (SWC-126): Making external calls to unvalidated addresses
           - Role mismanagement/Missing Access Modifiers: Missing or incorrect onlyOwner/role checks
           - Unprotected Upgradeability/Proxy Issues: Upgrade mechanism not protected
           - Incorrect Initialization: Constructor/init logic not executed or callable after deploy

        2. Arithmetic & Logic Errors
           - Integer Overflow and Underflow (SWC-101): Arithmetic wraparound corrupts balances/limits
           - Assert Violation (SWC-110): assert() misuse causes catastrophic reverts
           - Requirement Violation (SWC-123): Wrong or missing require() checks
           - Division-by-zero/Modulo-by-zero: Dividing/modulo by zero causes reverts
           - Logic errors in loops/off-by-one: Loop index mistakes or boundary errors
           - Unchecked math in subsequent state updates: Assuming math results are safe without checks

        3. Code Quality & Maintenance
           - Outdated Compiler Version (SWC-102): Using old compilers misses security fixes
           - Floating Pragma (SWC-103): Loose compiler versions may compile under unintended semantics
           - Use of Deprecated Solidity Functions (SWC-111): Old/removed features produce unexpected behavior
           - Incorrect Constructor Name (SWC-118): Pre-0.4-style constructors named wrong remain callable
           - Shadowing State Variables (SWC-119): Redeclaring state vars in derived contracts
           - Incorrect Inheritance Order (SWC-125): Wrong linearization leads to unexpected overrides
           - Arbitrary Jump/Bad Assembly (SWC-127): Unsafe inline assembly or function-pointer jumps
           - Unused Variables/Dead Code: Leftover code can hide logic
           - Incorrect Event Emission: State changes not logged correctly
           - Gas optimization/expensive storage usage: Inefficient loops/storage can enable DoS
           - Incorrect use of selfdestruct in maintenance: Maintenance patterns without safeguards

        4. Reentrancy, Calls & External Interaction
           - Unchecked Call Return Value (SWC-104): Not checking .call() results
           - Unprotected SELFDESTRUCT Instruction (SWC-106): selfdestruct callable by anyone
           - Reentrancy single-function (SWC-107): External calls before state updates let attacker re-enter
           - Cross-function Reentrancy: Reentrancy that chains through different public functions
           - Delegatecall to Untrusted Callee (SWC-112): delegatecall to untrusted address executes arbitrary code
           - Call Injection/Untrusted delegatecall libraries: Passing user-controlled address/data to library calls
           - DoS with Failed Call (SWC-113): Single failing external call can stop processing
           - External call with state-change after call (CEI violation): Updating state after external call

        5. Blockchain-Specific / DeFi & Economic
           - Transaction Order Dependence/Front-running (SWC-114): Miner/bot can reorder mempool txs to profit
           - Block values as proxy for time/Timestamp Dependence (SWC-116): block.timestamp can be influenced
           - Weak Sources of Randomness (SWC-120): Using blockhash/timestamp as RNG
           - DoS with Block Gas Limit/Unbounded Loop (SWC-128): Unbounded loops exceed gas limit
           - Oracle & off-chain data manipulation: Trusted off-chain feeds can be manipulated
           - Economic/Game-theory vulnerabilities: Flash loans, liquidation mechanics, debt cycles
           - Sandwich/MEV-style attacks: Bots exploit price impact by sandwiching victim trades
           - Cross-contract economic coupling: Unexpected interactions between protocols

        6. Cryptography, Signature & Data Handling
           - Signature Malleability (SWC-117): ECDSA malleability allows alternate valid signatures
           - Missing Protection against Signature Replay (SWC-121): Signed messages used more than once
           - Lack of Proper Signature Verification (SWC-122): Using ecrecover incorrectly
           - Weak Hash Functions/truncated hashes: Using weak or truncated hashes
           - Replay/front-run risks for off-chain signed messages: Signed orders can be replayed
           - Encoding/Decoding/ABI errors: Malformed ABI decoding allows crafted inputs
           - Uninitialized Storage Pointer (SWC-109): Local storage pointer not initialized
           - Write to Arbitrary Storage Location (SWC-124): Incorrect storage indexing corrupts variables
           - Storage layout/collision bugs: Upgrading implementations with mismatched storage layout
           - Unchecked External Input: Failing to validate user inputs
           - Generous Contracts (SWC-105): Overly permissive functions allow anyone to withdraw/mint
        
        Based on the vulnerability description, return EXACTLY this JSON object with ONE of these category names:
        - "Access Control & Authorization"
        - "Arithmetic & Logic Errors"
        - "Code Quality & Maintenance"
        - "Reentrancy, Calls & External Interaction"
        - "Blockchain-Specific / DeFi & Economic"
        - "Cryptography, Signature & Data Handling"

        Return JSON:
        {
          "type": "Category name from the list above"
        }
        
        Text to classify:
        """
        + entry
    )
    
    response = openai.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "You are a smart contract security expert. Classify the vulnerability into exactly one of the six provided categories."},
            {"role": "user", "content": prompt}
        ],
        temperature=0
    )

    content = response.choices[0].message.content.strip()
    
    # Try direct JSON parse
    try:
        result = json.loads(content)
        # Validate that the type is one of our categories
        valid_categories = [
            "Access Control & Authorization",
            "Arithmetic & Logic Errors", 
            "Code Quality & Maintenance",
            "Reentrancy, Calls & External Interaction",
            "Blockchain-Specific / DeFi & Economic",
            "Cryptography, Signature & Data Handling"
        ]
        if result.get("type") not in valid_categories:
            print(f"Warning: Invalid category '{result.get('type')}'. Setting to 'unknown'.")
            result["type"] = "unknown"
        return result
    except Exception:
        pass
    
    # Try extracting from ```json ... ``` block
    code_blocks = re.findall(r'```json(.*?)```', content, re.DOTALL)
    if code_blocks:
        try:
            result = json.loads(code_blocks[0].strip())
            # Validate category
            valid_categories = [
                "Access Control & Authorization",
                "Arithmetic & Logic Errors",
                "Code Quality & Maintenance", 
                "Reentrancy, Calls & External Interaction",
                "Blockchain-Specific / DeFi & Economic",
                "Cryptography, Signature & Data Handling"
            ]
            if result.get("type") not in valid_categories:
                print(f"Warning: Invalid category '{result.get('type')}'. Setting to 'unknown'.")
                result["type"] = "unknown"
            return result
        except Exception:
            pass
    
    # Fallback: any json-like object in output
    obj_match = re.search(r'\{[\s\S]*\}', content)
    if obj_match:
        try:
            result = json.loads(obj_match.group(0))
            # Validate category
            valid_categories = [
                "Access Control & Authorization",
                "Arithmetic & Logic Errors",
                "Code Quality & Maintenance",
                "Reentrancy, Calls & External Interaction",
                "Blockchain-Specific / DeFi & Economic",
                "Cryptography, Signature & Data Handling"
            ]
            if result.get("type") not in valid_categories:
                print(f"Warning: Invalid category '{result.get('type')}'. Setting to 'unknown'.")
                result["type"] = "unknown"
            return result
        except Exception:
            pass
    
    print(f"Warning: Failed to parse model output. Content: {content!r}")
    return {
        "type": "unknown",
    }

def process_json_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    if isinstance(data, dict):
        objects = [data]
        is_single_object = True
    elif isinstance(data, list):
        objects = data
        is_single_object = False
    else:
        print(f"Skipping {file_path}, unexpected JSON root type.")
        return

    modified = False
    for obj in objects:
        title = obj.get("title", "")
        description = obj.get("description", "")
        recommendation = obj.get("recommendation", "")
        category = obj.get("type", "")
        
        # Only process if type is missing or empty
        if not category and title and description:
            result = get_vulnerability_type(obj)
            if not obj.get('type'):
                obj['type'] = result.get("type", "unknown")
                modified = True
                print(f"  Classified as: {obj['type']}")

    if modified:
        with open(file_path, 'w', encoding='utf-8') as f:
            if is_single_object:
                json.dump(objects[0], f, indent=2, ensure_ascii=False)
            else:
                json.dump(objects, f, indent=2, ensure_ascii=False)
        print(f"Updated {file_path}")
    else:
        print(f"No changes needed for {file_path}")


if __name__ == "__main__":
    import sys
    import argparse
    
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Classify Web3 vulnerabilities in JSON files')
    parser.add_argument('directory', nargs='?', 
                       default="/Users/matt/vulnaut/golden_dataset/dedaub",
                       help='Directory to process (default: /Users/matt/vulnaut/golden_dataset/dedaub)')
    parser.add_argument('--recursive', '-r', action='store_true',
                       help='Process directory recursively')
    
    args = parser.parse_args()
    
    # Validate directory exists
    if not os.path.exists(args.directory):
        print(f"Error: Directory '{args.directory}' does not exist.")
        sys.exit(1)
    
    if not os.path.isdir(args.directory):
        print(f"Error: '{args.directory}' is not a directory.")
        sys.exit(1)
    
    # Statistics tracking
    category_counter = Counter()
    processed_files = 0
    updated_files = 0
    
    # Get JSON files based on recursive flag
    if args.recursive:
        print(f"Searching for JSON files recursively in: {args.directory}")
        json_files = list(find_json_files(args.directory))
    else:
        print(f"Searching for JSON files in: {args.directory}")
        json_files = [os.path.join(args.directory, f) 
                     for f in os.listdir(args.directory) 
                     if f.lower().endswith('.json')]
    
    if not json_files:
        print("No JSON files found in the specified directory.")
        sys.exit(0)
        
    print(f"Found {len(json_files)} JSON files to process.\n")
    
    for json_file in tqdm(json_files, desc="Processing files"):
            try:
                # Read file to check current state
                with open(json_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Process the file
                process_json_file(json_file)
                processed_files += 1
                
                # Track categories after processing
                if isinstance(data, dict):
                    if data.get('type'):
                        category_counter[data['type']] += 1
                elif isinstance(data, list):
                    for obj in data:
                        if obj.get('type'):
                            category_counter[obj['type']] += 1
                            
            except Exception as e:
                print(f"\nError processing {json_file}: {e}")
    
    # Print summary statistics
    print("\n" + "="*60)
    print("PROCESSING COMPLETE")
    print("="*60)
    print(f"Directory processed: {args.directory}")
    print(f"Total files processed: {processed_files}")
    print(f"\nVulnerability Category Distribution:")
    print("-"*40)
    for category, count in category_counter.most_common():
        print(f"  {category}: {count}")
    print("-"*40)
    print(f"Total categorized vulnerabilities: {sum(category_counter.values())}")